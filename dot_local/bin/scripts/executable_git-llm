#!/bin/bash

set -euo pipefail
IFS=$'\n\t'

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m' # No Color

# Generate commit message using LLM with JSON output
generate_commit_message() {
  local last_commits
  last_commits=$(git log -3 --pretty=format:"- %s" 2>/dev/null)
  local diff_output
  diff_output=$(git diff --cached)

  if [[ -z "$diff_output" ]]; then
    printf "${RED}No staged changes found to generate commit message.${NC}\n" >&2
    return 1
  fi

  local prompt
  prompt="CRITICAL: You MUST respond with ONLY the JSON object below, filled in with your analysis. Do not add any other text, markdown, or explanation.

RESPOND WITH THIS EXACT JSON TEMPLATE, FILLED IN:

{
  \"overview\": \"High-level summary of all changes across the diff\",
  \"detailed_analysis\": \"Detailed breakdown of what changed and why\",
  \"commits\": [
    {
      \"title\": \"type(scope): brief description under 72 chars\",
      \"description\": \"Detailed explanation of this specific commit\",
      \"files_affected\": [\"file1\", \"file2\"]
    }
  ]
}

INSTRUCTIONS:
- Analyze the diff and determine if multiple logical commits are needed
- If changes are related and should be one commit, provide 1 commit object
- If changes are distinct and should be separate commits, provide multiple commit objects (2-4 max)
- Each commit must follow conventional commit format (feat, fix, docs, style, refactor, perf, test, chore)
- Keep titles under 72 characters
- Provide detailed descriptions explaining the why and what
- List the files affected by each commit (use exact file paths from the diff)
- Return ONLY the JSON object, nothing else
- Do not use markdown code fences
- Do not add any text before or after the JSON

CONTEXT - Recent commits:
$last_commits

DIFF TO ANALYZE:
$diff_output"

  echo "$prompt" | llm
}

# Parse LLM response
parse_llm_response() {
  local response="$1"
  
  # Validate JSON directly with jq
  if echo "$response" | jq empty 2>/dev/null; then
    echo "$response"
    return 0
  fi
  
  printf "${RED}Error: Invalid JSON in LLM response${NC}\n" >&2
  printf "${YELLOW}Response:${NC}\n%s\n" "$response" >&2
  return 1
}

# Display overview and detailed analysis
display_analysis() {
  local overview="$1"
  local detailed_analysis="$2"
  
  printf "\n"
  gum style --foreground 4 --border normal --margin "0 1" --padding "0 1" "ðŸ“‹ Overview"
  printf "%s\n" "$overview"
  
  printf "\n"
  gum style --foreground 6 --border normal --margin "0 1" --padding "0 1" "ðŸ” Detailed Analysis"
  printf "%s\n" "$detailed_analysis"
  printf "\n"
}

# Display all commits preview
display_commits_preview() {
  local json_response="$1"
  local num_commits
  
  num_commits=$(echo "$json_response" | jq '.commits | length')
  
  printf "\n"
  gum style --foreground 3 --border normal --margin "0 1" --padding "0 1" "ðŸ“¦ Commits (${num_commits})"
  
  for i in $(seq 0 $((num_commits - 1))); do
    local title
    local description
    local files
    
    title=$(echo "$json_response" | jq -r ".commits[$i].title")
    description=$(echo "$json_response" | jq -r ".commits[$i].description")
    files=$(echo "$json_response" | jq -r ".commits[$i].files_affected | join(\", \")")
    
    printf "\n${MAGENTA}[Commit $((i + 1))/${num_commits}]${NC}\n"
    printf "${CYAN}Title:${NC} %s\n" "$title"
    printf "${CYAN}Files:${NC} %s\n" "$files"
    if [[ -n "$description" && "$description" != "null" ]]; then
      printf "${CYAN}Description:${NC}\n%s\n" "$description"
    fi
  done
  printf "\n"
}

# Ask for overall confirmation
confirm_all_commits() {
  if gum confirm "Proceed with these commits?"; then
    return 0
  else
    printf "${YELLOW}âœ— Commit cancelled${NC}\n"
    return 1
  fi
}

# Confirm individual commit
confirm_individual_commit() {
  local commit_num="$1"
  local total_commits="$2"
  
  if gum confirm "Commit $commit_num/$total_commits - Proceed?"; then
    return 0
  else
    printf "${YELLOW}âŠ˜ Skipped commit $commit_num${NC}\n"
    return 1
  fi
}

# Stage files for a specific commit
stage_commit_files() {
  local json_response="$1"
  local commit_index="$2"
  
  # Get files for this commit
  local files
  files=$(echo "$json_response" | jq -r ".commits[$commit_index].files_affected[]")
  
  # Stage each file
  while IFS= read -r file; do
    if [[ -n "$file" ]]; then
      if git add "$file" 2>/dev/null; then
        printf "  Staged: %s\n" "$file"
      else
        printf "${YELLOW}  Warning: Could not stage %s${NC}\n" "$file" >&2
      fi
    fi
  done <<< "$files"
}

# Execute commits
execute_commits() {
  local json_response="$1"
  local num_commits
  local committed_count=0
  local skipped_count=0
  
  num_commits=$(echo "$json_response" | jq '.commits | length')
  
  printf "\n"
  gum style --foreground 2 --border normal --margin "0 1" --padding "0 1" "ðŸš€ Executing Commits"
  
  for i in $(seq 0 $((num_commits - 1))); do
    local title
    local description
    
    title=$(echo "$json_response" | jq -r ".commits[$i].title")
    description=$(echo "$json_response" | jq -r ".commits[$i].description")
    
    printf "\n"
    if confirm_individual_commit $((i + 1)) "$num_commits"; then
      # Stage files for this commit
      printf "${BLUE}Staging files for commit $((i + 1))...${NC}\n"
      stage_commit_files "$json_response" "$i"
      
      # Build commit message
      local commit_msg="$title"
      if [[ -n "$description" && "$description" != "null" ]]; then
        commit_msg="${commit_msg}

${description}"
      fi
      
      # Check if there are staged changes
      if git diff --cached --quiet; then
        printf "${YELLOW}âš  No changes staged for this commit${NC}\n"
        ((skipped_count++))
      elif git commit -m "$commit_msg"; then
        printf "${GREEN}âœ“ Commit $((i + 1)) successful${NC}\n"
        ((committed_count++))
      else
        printf "${RED}âœ— Commit $((i + 1)) failed${NC}\n" >&2
        return 1
      fi
    else
      ((skipped_count++))
    fi
  done
  
  printf "\n"
  printf "${GREEN}âœ“ Completed: %d committed, %d skipped${NC}\n" "$committed_count" "$skipped_count"
}

# Main function
gcm() {
  local temp_output
  temp_output=$(mktemp)
  local diff
  diff=$(git diff --cached)

  if [[ -z "$diff" ]]; then
    printf "${YELLOW}No staged changes.${NC}\n"
    return 1
  fi

  printf "${BLUE}â³ Analyzing changes...${NC}\n"
  
  if ! generate_commit_message > "$temp_output" 2>&1; then
    local error_msg
    error_msg=$(cat "$temp_output")
    rm -f "$temp_output"
    printf "${RED}Error: LLM request failed${NC}\n" >&2
    printf "${YELLOW}Details:${NC}\n%s\n" "$error_msg" >&2
    return 1
  fi

  local raw_response
  raw_response=$(cat "$temp_output")
  rm -f "$temp_output"
  
  local json_response
  if ! json_response=$(parse_llm_response "$raw_response"); then
    return 1
  fi

  # Extract overview and analysis
  local overview
  local detailed_analysis
  
  overview=$(echo "$json_response" | jq -r '.overview // empty')
  detailed_analysis=$(echo "$json_response" | jq -r '.detailed_analysis // empty')

  if [[ -z "$overview" ]]; then
    printf "${RED}Error: Overview is empty${NC}\n" >&2
    return 1
  fi

  # Display analysis
  display_analysis "$overview" "$detailed_analysis"
  
  # Display commits preview
  display_commits_preview "$json_response"
  
  # Ask for overall confirmation
  if ! confirm_all_commits; then
    return 1
  fi
  
  # Execute commits with individual confirmations
  execute_commits "$json_response"
}

main() {
  gcm
}

main "$@"
