#!/usr/bin/env bash

set -euo pipefail
IFS=$'\n\t'

generate_commit_message() {
  local last_commits
  last_commits=$(git log -3 --pretty=format:"- %s" 2>/dev/null)
  local diff_output
  diff_output=$(git diff --cached)

  if [[ -z "$diff_output" ]]; then
    printf "No staged changes found to generate commit message.\n" >&2
    return 1
  fi

  printf "%s\n" "$diff_output" | llm "
Below is a diff of all staged changes, coming from the command:
\`\`\`
git diff --cached
\`\`\`

For context, here are the last 3 commit messages:
$last_commits

Please generate a concise, one-line conventional commit message for these changes that follows a similar style to the previous commits.

you can include thoughts, but make sure you prefix with # as comments for the editor.

start your response with # Analysis:
"
}

confirm_commit_message() {
  local message="$1"

  gum style --foreground 212 --border normal --margin "1 2" --padding "1 2" "$message"

  # Automatically commit without confirmation
  if git commit -m "$message"; then
    printf "Changes committed successfully!\n"
  else
    printf "Commit failed. Please check your changes and try again.\n" >&2
    return 1
  fi
}

gcm() {
  local temp_output
  temp_output=$(mktemp)
  local diff
  diff=$(git diff --cached)

  if [[ -z "$diff" ]]; then
    printf "No staged changes.\n"
    return 1
  fi

  printf "\x1b[2mthinking...\n"
  if ! generate_commit_message | tee "$temp_output"; then
    rm -f "$temp_output"
    printf "\x1b[0m"
    return 1
  fi
  printf "\x1b[0m"

  local commit_message
  commit_message=$(grep -v '^#' "$temp_output" | grep -v '^[[:space:]]*$' | tail -n 1)
  rm -f "$temp_output"

  if [[ -z "$commit_message" ]]; then
    printf "Generated commit message is empty.\n" >&2
    return 1
  fi

  confirm_commit_message "$commit_message"
}

main() {
  gcm
}

main "$@"
